# 垃圾回收

## 垃圾识别

* GC Root【可达性判断】
  * 虚拟机栈中引用的对象
  * 方法区静态属性引用的对象
  * 方法区常量引用的对象
  * JNI 引用的对象
  * java虚拟机内部的引用
  * 被synchronized 修饰的
* 引用计数法
  * 不能解决循环引用问题

## 分代收集

* 组成
  * 新生代
    * Eden
      * from&#x20;
      * to
  * 老年代
* 跨带收集【新生代引用老年代对象】
  * 卡表为一个比特位集合，每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用。这样在新生代GC时，可以不用花大量时间扫描所有的老年代对象来确定每一个对象的引用关系，可以先扫描卡表，只有当卡表的标记位为1时，才需要扫描给定区域的老年代对象，而卡表位为0的老年代对象，一定不含有新生代对象的引用

## 对象进入老年代时机

* 大对象。
  * 超过from 区大小
  * PretenureSizeThreshold，它用来设置对象直接晋升到老年代的阈值，单位是字节。只要对象的大小大于指定值，就会绕过新生代，直接在老年代分配。这个参数只对串行回收器和ParNew有效，对于ParallelGC无效。
* 最大新生代年龄，MaxTenuringThreshold。达到这个年龄一定晋升，但是没有达到这个年龄对象也也有可能晋升。
* 动态年龄判断。年龄1+年龄2+年龄3+年龄N的对象加起来的空间，大于survivor区域的一半，就会让年龄N和年龄N以上的对象进入老年代
* Minor GC后，存活的对象空间大于survivor空间，直接进入老年代。



## 分区收集

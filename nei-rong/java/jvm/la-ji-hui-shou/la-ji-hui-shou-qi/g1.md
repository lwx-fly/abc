---
description: G1
---

# G1

## 回收流程

* 新生代回收
  * eden 区占满
* 并发标记周期
  1. 初始标记。标记从根节点直接可达的对象，会伴随一次young gc。会产生stw
  2. 根区域扫描。
     1. 在这个阶段，将扫描由survivor区直接可达的老年代区域，并标记这些直接可达的对象。这个过程是可以和应用程序并发执行的。
     2. 但是<mark style="color:red;">根区域扫描不能和新生代 GC 同时执行</mark>（因为根区域扫描依赖 survivor 区的对象，而新生代GC会修改这个区域）。
     3. 如果恰巧在此时需要进行新生代GC，就需要等待根区域扫描结束后才能进行。
  3. 并发标记。可以被young gc 打断
  4. 重新标记。会产生stw
  5. 独占清理。
     1. 这个阶段是会引起停顿的。
     2. <mark style="color:red;">它将计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可供混合回收的区域</mark>。
     3. 在这个阶段，还会更新记忆集（Remebered Set）。
  6. 并发清理。这里<mark style="color:red;">会识别并清理完全空闲的区域</mark>。它是并发的清理，不会引起停顿。
* 混合回收
  * 既会执行正常的young gc，也会选取老年代区域进行回收
  * 会回收多次，直到有了足够的内存空间
  * 又回触发一次新的young gc。
* 必要时full gc
  * 在混合GC时空间不足，或者在新生代GC时survivor区和老年代无法容纳幸存对象，都会导致一次Full GC。

## 适用

* 大内存【超过4g】
* 响应时间优先

## 分区收集

* <mark style="color:red;">记忆集</mark>是G1中维护的一个数据结构，简称RS。每一个G1区域都有一个RS与之关联
* G1在区域A的RS中，记录了在区域A中被其他区域引用的对象，这样在回收区域A时，只要将RS视为区域A根集的一部分即可，从而避免做整个堆的扫描

## 漏标问题解决

* <mark style="color:red;">原始快照方式</mark>
* 灰色对象取消引用前，将灰色引用的白色对象记录下来。在重新标记阶段再以白色对象为根对其引用进行扫描，从而避免漏标。
* 产生浮动垃圾。

## 回收算法

* 标记整理
* 让所有存活对象移动到一端，然后清理掉边界以外的内存

## 参数

* \-XX：+UseG1GC：使用G1回收器。
* <mark style="color:red;">·-XX：MaxGCPauseMillis：设置最大垃圾回收停顿时间。</mark>
* \-XX：GCPauseIntervalMillis：设置停顿间隔时间。
